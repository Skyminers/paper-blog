---
author: Sky_miner
pubDatetime: 2024-08-04T01:48:39.000+08:00
# modDatetime:
title: 面试 Cheat Book
featured: false
draft: false
tags:
  - docs
description: 网上总结的面试 Cheat Book
---

## Table of contents

## C++ 相关

### C++ 虚函数

一般定义虚函数时是为了多态，允许基类的虚函数指针调用不同子类对该虚函数实现的不同功能。虚函数分为了虚函数和纯虚函数，虚函数是有默认的功能实现的，纯虚函数是没有实现的，要求子类必须实现这个函数。

纯虚函数的定义方式是在定义的语句后面加`=0`，例如：`virtual void funtion1()=0`

## Python 相关

### Python 可变对象与不可变对象

不可变对象是不可变的，当修改这类对象时实际上是创建了一个新的对象并修改引用，并且对原来的不可变对象进行回收。可变对象是可变的，修改的话就是直接修改这个对象。

- 不可变对象：int, float, str, tuple
- 可变对象：list, dict, set

## 机器学习相关

### Batchnorm 与 LayerNorm

作用都是将输入的数据归一化，均值变为 $0$，方差变为 $1$。

Batchnorm 是对每个 batch 的某一个维度组合成的特征进行归一化，LayerNorm 是对每个样本的特征进行归一化。Transformers 中使用 LayerNorm，因为理解上来说不同 Batch 样本中的某个特征不存在相关性，而同一个样本中的特征之间存在相关性。大部分样本 embedding 是没有意义的，少部分是有意义的，如果使用 Batchnorm 可能反而会破坏这些有意义的 embedding。

![](@assets/images/cheat-book/batch-layer-norm.png)

### Batchnorm 有哪些参数

可学习参数：

- $\gamma$：缩放因子，控制标准化后的数据 scale，训练过程中每一个特征通道都有一个可学习的缩放因子。
- $\beta$：偏移因子，控制标准化后的数据 shift，训练过程中每一个特征通道都有一个可学习的偏移因子。

不可学习参数：全局均值和全局方差。

### Vit 为什么加入 cls 分类 token？相比直接在最后用第一个有什么好处？

Token 可以捕获全局的信息，如果直接用第一个的话可能会跟第一个 Patch 有很强的关系，无法有效捕获其他 Patch 的信息。

### Transformer 为什么要除以根号 dk

因为在计算 Attention 时，计算的是 $Q \cdot K^T$，如果不除以根号 dk，那么 $Q \cdot K^T$ 的值会很大，导致 Softmax 后的值很小，这样会导致梯度消失。

## 八股文

### OSI模型有了解吗？它和TCP/IP模型之间的区别是什么？

OSI 七层模型：

1. 物理层（Physical Layer）：负责在物理媒介上传输原始比特流。
2. 数据链路层（Data Link Layer）：确保物理层传输的数据无误，通过帧的方式传输数据。
3. 网络层（Network Layer）：负责数据包从源到目的地的传输和路由选择。
4. 传输层（Transport Layer）：为应用程序提供端到端的数据传输服务。
5. 会话层（Session Layer）：管理设备间的会话连接。
6. 表示层（Presentation Layer）：处理数据的表示、编码和转换。
7. 应用层（Application Layer）：为应用软件提供网络服务。

TCP/IP模型是一个四层协议模型，用于互联网通信。它包括以下层：

1. 链路层（Link Layer）：与OSI模型的物理层和数据链路层相对应，负责在物理媒介上传输数据帧。
2. 网络层（Internet Layer）：与OSI的网络层相对应，主要使用IP协议进行数据包的传输和路由选择。
3. 传输层（Transport Layer）：与OSI模型的传输层相对应，包括TCP和UDP协议，提供端到端的数据传输服务。
4. 应用层（Application Layer）：与OSI模型的应用层相对应，包括各种网络应用协议，如HTTP、FTP等。

### 进程、线程、协程的区别和通信

进程、线程和协程是操作系统中用于执行程序的基本单位，它们之间有以下区别：

1. **进程（Process）**：

   - 进程是操作系统进行资源分配和调度的一个独立单位。
   - 每个进程都有独立的地址空间，进程间的切换开销较大。
   - 进程间通信（IPC）需要特定的机制，如管道、消息队列、共享内存等。

2. **线程（Thread）**：

   - 线程是进程中的一个实体，是CPU调度和执行的单位。
   - 同一进程中的多个线程共享进程的资源，如内存空间和文件描述符。
   - 线程的创建和切换开销比进程小。
   - 线程间通信可以通过共享内存来实现，但需要同步机制来避免竞态条件。

3. **协程（Coroutine）**：
   - 协程是一种程序组件，它允许挂起和恢复执行，通常用于处理I/O密集型任务。
   - 协程通常不拥有独立的内存空间，而是运行在某个线程中，共享线程的资源。
   - 协程的切换开销最小，由程序控制，不需要操作系统介入。
   - 协程主要用于编写异步代码，提高程序的并发性能。

进程之间的通信方式主要包括以下几种：

1. **管道（Pipe）**：一种半双工通信方式，数据只能在一个方向上流动，通常用于父子进程或兄弟进程之间的通信。

2. **命名管道（Named Pipe）**：类似于管道，但是它允许不相关的进程以FIFO（先进先出）的方式进行通信。

3. **消息队列（Message Queue）**：消息队列允许进程发送和接收消息，消息以队列的形式存储。

4. **共享内存（Shared Memory）**：一块可以被多个进程访问的内存区域，进程可以直接读写这块内存来交换数据。

5. **套接字（Socket）**：一种端到端的通信方式，支持不同的网络协议，可以用于进程间或网络中的通信。

6. **信号（Signal）**：一种异步通信方式，用于通知进程某个事件已经发生。

7. **信号量（Semaphore）**：用于控制多个进程对共享资源的访问。

8. **文件映射（Memory-mapped Files）**：将文件或者内存段映射到进程的地址空间，实现进程间的通信。

每种通信方式都有其适用场景和限制，开发者需要根据具体需求选择合适的通信机制。

### 为什么说Linux的设计哲学是一切皆文件？inode的作用是什么？软链接和硬链接的区别？

Linux的设计哲学中有一条是“一切皆文件”，这主要体现在以下几个方面：

1. **统一的接口**：在Linux系统中，几乎所有的设备和资源都通过文件的形式呈现给用户，使用统一的系统调用接口进行访问，这简化了编程和系统管理。

2. **抽象化**：通过文件抽象，Linux隐藏了底层硬件和设备的具体细节，为用户提供了一致的操作方式。

3. **灵活性**：由于一切资源都可以通过文件操作，这使得Linux系统非常灵活，可以很容易地扩展和修改。

4. **模块化**：这种设计哲学支持模块化，各个组件可以独立开发和维护，同时保持一致的接口。

**inode（索引节点）**的作用如下：

- inode是文件系统中存储文件信息的数据结构，每个文件或目录都有一个对应的inode。
- inode包含了文件的元数据，如文件大小、权限、所有者、创建和修改时间等，但不包含文件名或文件数据本身。
- 文件数据存储在inode指向的数据块中，inode通过数据块号来访问这些数据块。
- inode的存在使得文件名和文件数据可以分离，便于实现文件的快速访问和硬链接等功能。

**软链接（Symbolic Link）**和**硬链接（Hard Link）**的区别：

1. **数据存储方式**：

   - 软链接：类似于Windows系统中的快捷方式，它存储的是指向目标文件的路径。
   - 硬链接：实际上是文件数据块的另一个文件名，它直接指向文件的inode。

2. **对文件的影响**：

   - 软链接：删除目标文件后，软链接会变成死链接（dangling link）。
   - 硬链接：删除目标文件不会影响硬链接，因为硬链接指向的是同一个inode。

3. **对目录的支持**：

   - 软链接：可以链接到目录，但使用时需要注意，因为可能会导致循环引用。
   - 硬链接：通常不允许链接到目录，以避免目录树结构的混乱。

4. **创建方式**：

   - 软链接：使用`ln -s`命令创建。
   - 硬链接：使用`ln`命令创建，但需要注意不能在不同文件系统之间创建硬链接。

5. **文件系统限制**：
   - 软链接：几乎不受文件系统限制。
   - 硬链接：受文件系统支持的限制，如某些文件系统不支持硬链接。

总的来说，软链接和硬链接都是Linux系统中实现文件链接的方式，但它们在实现机制和使用场景上有所不同。

## 智力/算法题

### 如何在 1T 的数据中寻找中位数

快速选择：每次找中间点，然后遍历一遍，将小于中间点的放左边，大于中间点的放右边，然后递归。

### 如何在大批量数据中寻找重复数据

> 给定 `a,b` 两个文件，各存放 $50$ 亿的数据，每个数据大小 `64B`, 内存限制 `4GB`，如何找出 `a,b` 两个文件的重复数据？

分治 + 哈希来做。首先通过计算算出数据的大致大小 $50 \times 10^8 \times 64\text{B} \approx 320\text{GB}$。考虑将两个文件中的数据各划分为 $1000$ 份，这样每一份文件大小大概是 $320\text{MB}$，内存可以完整装载每一份文件。对每一个数据进行 Hash，将 `hashValue % 1000` 的结果作为标号，将数据分别存储到 $1000$ 个文件中。这样我们就有了文件一对应的 $1000$ 份文件和文件二对应的 $1000$ 份文件。我们将这 $2000$ 份文件分为标号相同的 $1000$ **对**文件，所有可能的重复数据只可能出现在同一对文件中，这样我们就将问题规模缩小到了 $320\text{MB}$。然后我们就可以将每一对文件的第一份全部加入到 `HashSet` 中，然后枚举第二份文件的数据，如果在 `HashSet` 中出现过，那么就是重复数据。

### 如何在大批量数据中寻找出现次数最多的 K 个数据

> 有一个 $1\text{GB}$ 大小的文件，文件里每一行是一个词，每个词的大小不超过 $16\text{B}$，内存大小限制是 $1\text{1MB}$，要求范围频数最高的 $100$ 个词。

为了满足内存限制，我们仍然需要先采取划分的方式来将大文件分割成小文件。可以按照 `hash(x) % 5000` 来进行划分，如果划分后仍不满足就继续划分。划分之后用 `Hashmap` 统计出现次数即可，统计完所有文件的所有词的出现次数之后再开一个小根堆，如果某一个数字大于堆顶元素就将其加入到堆中。维护堆的大小不超过 K 即可。

### 如何在一个超大文件中找到出现次数最多的数据

与上一题同理，超大文件无法直接读入内存，那就需要一边读入一边将信息写出到文件中，先划分，再统计每个文件内数据的出现次数，最后求 `max`。

### 如何在 2.5 亿个整数中找出不重复的整数（内存无法容纳完整的这些数字）

有两种方法：

1. 按照跟之前一样的方法，按照哈希余数进行划分，然后分别统计再整合。
2. 位图法，简单来说就是操作二进制位来进行判断。空间占用与整数的大小有关，如果数字过于稀疏可能反而会导致更大的占用。也有一种位图索引的方法例如 `RoaringBitmap` 可以进行压缩。从最朴素的位图来说，可以将大小为 $x$ 的数字映射到第 $2x$ 和第 $2x+1$ 个二进制位中，利用二进制位来表示状态：`00` 表示未出现过, `01` 表示出现过一次, `10` 表示出现过多次。这样的话假设所有整数都在 `int` 范围内，那么只需要 $2*2^{32}$ 个二进制位，也就是 $1\text{GB}$ 的空间。

### 如何在 40 亿个整数中判断某个数字是否出现过

1. 可以按照哈希余数进行划分，然后再分别判断。
2. 通过位图法，将数字映射到位图中，然后判断。

### 如何在 1000 万个记录中找到出现次数最多的记录

> 搜索引擎会通过日志文件把用户每次检索使用的所有查询串都记录下来，每个查询床的长度不超过 255 字节。
> 假设目前有 1000w 个记录（这些查询串的重复度比较高，虽然总数是 1000w，但如果除去重复后，则不超过 300w 个）。请统计最热门的 10 个查询串，要求使用的内存不能超过 1G。（一个查询串的重复度越高，说明查询它的用户越多，也就越热门。）

首先计算内存，每个串 $255\text{B}$，那么 $10 \times 10^7$ 大概就是 $2.55\text{GB}$ 的空间占用。肯定是无法直接读入的，所以我们可以选择：

1. 按照 Hash 结果划分为子问题，然后再统计
2. 因为题目中提到了重复的串比较多，所以我们可以考虑通过 HashMap 储存，占用空间 $300w*(255+4)\approx 777\text{MB}$
3. Trie 树。

## 如何在大量电话号码中统计不同号码的个数，每个号码为 8 位数字

位图法 $10^9 / 8 / 1024 / 1024 \approx 100\text{MB}$

## 如何从大量数字中找到中位数（5亿个数）

1. 双堆法
2. 二分中位数的值，二分之后将数据分为大于 mid 和小于 mid 的两个部分，然后递归操作。

## 参考链接

- [10 道 BAT 大厂海量数据面试题](https://cloud.tencent.com/developer/article/1550063)
